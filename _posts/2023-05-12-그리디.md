---
title: 그리디
categories:
- Algorithm
- 이것이 코딩 테스트다
tag: Algorithm
date: '2023-05-15 09:46:33'
---

# 그리디

[→ 슬리드로 보기](https://app.slid.cc/docs/19bec09dd9a746e6bf026bdba88700ca)


---

---


목차

- 거스름돈

- 그리디 알고리즘의 정당성

- 큰 수의 법칙

- 숫자 카드 게임

- 1이 될 때 까지

- 


‏‏‎ ‎


‏‏‎ ‎

---


**개념**

---


그리디(Greedy) 알고리즘은 단순하지만 강력한 문제 해결 방법이다.


이 알고리즘 유형은 국내 알고리즘 교재에서 단어 그대로 번역하여 '탐욕법'으로 소개 된다.


이름에서 알 수 있듯 어떠한 문제가 있을 때 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다.


여기서 탐욕적이란 말은 '현재 상황에서 지금 당장 좋은 것만 고르는 방법'을 의미한다.


그리디 알고리즘을 이용하면 매순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향 따윈 고려하지 않는다.


‏‏‎ ‎


그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다.


대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제 된다.

---

### 거스름돈

---


**문제**


당신은 음식점의 계산을 도와주는 점원이다.


카운터에는 거스르몯능로 사용할 500원, 100월, 50원, 10원짜리 동전이 무한히 존재한다.


손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야할 동전의 최소 개수를 구하라.


단 거슬러 줘야 할 돈 N은 항상 10의 배수이다.


**문제해설**


이 문제는 그리디 알고리즘을 이용해 풀 수 있는 대표적인 문제로 간단한 아이디어만 떠올릴 수 있으면 해결할 수 있다.


'가장 큰 화폐 단위'부터 돈을 거슬러 주면 된다.


N원을 거슬러 줘야 할 때, 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 준다.


그다음 100원, 50원, 10원 짜리 동전을 차례대로 거슬러 줄 수 있을만큼 거슬러 주면 최소의 동전 개수로 모두 거슬러 줄 수 있다.

```Python
n = 1260
count = 0

coin_types = [500, 100, 50, 10]  # 큰 단위의 화폐부터 차례대로 확인

for coin in coin_types:
  count += n // coin # 몫만 남김
  n %= coin  #나머지를 왼쪽에 할당
  
print(count)
```


코드를 보면 화폐 종류만큼 반복을 수행해야 한다.


따라서 화폐의 종류가 K개라고 할 때 위 소스코드의 시간 복잡도는 O(K)이다.


참고로 시간 복잡도에서 거슬러 주어야 할 돈 N은 찾아볼 수가 없다.


이 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고, 거슬러줘야 하는 금액의 크기와 무관하다는 것을 알 수 있다.

---

### 그리디 알고리즘의 정당성

---


그리디 알고리즘을 모든 알고리즘 문제에 적용할 수 있는 것은 아니다.


대부분의 문제는 그리디 알고리즘을 적용했을 때 '최적의 해'를 찾을 수 없는 가능성이 다분하다.


하지만 거스름돈 문제에서 가장 큰 화페 단위부터' 거슬러 주는 것과 같이, 탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적이다.


그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토해야한다.


거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.


예를 들어 800원을 거슬러 줘야 하는데, 화폐 단위가 500원, 400원, 100원인 경우를 생각해보자.


이 경우에 그리디 알고리즘으로는 4개의 동전(500원 + 100원 + 100원 + 100원)을 거슬러줘야한다고 나오는데, 최적의 해는 2개의 동전(400원 + 400원)을 거슬러 주는 것이다.


그래서 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

---

### 큰 수의 법칙

---


**문제**


'큰 수의 법칙은' 일반적으로 통계 분야에서 다루어지는 내용이지만 프리는 본인만의 방식으로 다르게 사용하고 있다.


프리의 큰 수의 법칙은 다양한 수로 이뤄진 배열이 존재할 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.


단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.


배열의 크기 N, 숫자가 더해지는 횟수 M, K가 주어질 때 프리의 큰 수의 법칙에 따른 결과를 출력하시오.


**입력조건**

[![그리디 image](https://slid-users-assets-v1-seoul.s3.ap-northeast-2.amazonaws.com/public/capture_images/19bec09dd9a746e6bf026bdba88700ca/c0ab31a3-7b79-4efd-90e5-dcdb004c652d.png)](undefined)


**출력 조건**

[![그리디 image](https://slid-users-assets-v1-seoul.s3.ap-northeast-2.amazonaws.com/public/capture_images/19bec09dd9a746e6bf026bdba88700ca/c9efcbe1-7b6d-4574-82a1-d5111939e287.png)](undefined)


‏‏‎ ‎


**문제 해설**


이 문제는 전형적인 그리디 알고리즘 문제라고 한다.


문제 해결을 위한 아이디어를 떠올리는 것을 어렵지 않은 편이다.


다만, 문제 해결을 위한 아이디어를 떠올렸어도 구현 실수로 인해 오답 처리를 받는 경우가 많은 문제이므로 꼭 직접 코드를 작성해보자.


이 문제를 해결하려면 일단 입력값 중에서 가장 큰 수와 두 번째로 큰 수만 저장하면 된다.


연속으로 더할 수 있는 횟수는 최대 K번이므로 '가장 큰 수를 K번 더하고 두 번째로 큰 수를 한 번 더하는 연산'을 반복하면 된다.


‏‏‎ ‎


이를 소스코드로 표현하면 아래와 같다.

```Python
n, m, k = map(int, input().split())

data = list(map(int, input().split()))

data.sort()
first = data[n - 1]
second = data[n - 2]

result = 0

while True:
  for i in range(k):
    if m == 0:
      break
      
    result += first 
    m -= 1
  if m == 0:
    break
  result += second
  m -= 1 
  
print(result)
```


문제는 여기서 M이 10000 이하 이므로 이 방식으로도 문제를 해결할 수 있지만, M의 크기가 100억 이상처럼 커진다면 시간 초과 판정을 받을 것이다.


간단한 수학적 아이디어를 사용해 더 효율적으로 처리해보자.

- 가장 큰 수 : 6

- 두 번째로 큰 수 : 5


이 때 M이 8이고, K가 3이라면 다음과 같이 더했을 때 합을 최대로 할 수 있다.


다시 말해 (6 + 6 + 6 + 5) + (6 + 6 + 6 + 5) = 46이 된다.


우선 효율적인 수학적 아이디어를 이용하려면 반복되는 수열에 대해서 먼저 파악을 해야한다.


반복되는 수열의 길이를 먼저 계산을 하면 반복되는 수열의 길이는 (K + 1)로 고정되게 된다.


M을 (K + 1)로 나눴을 때 숫자가 더해지는 횟수 / 수열의 길이 라는 식으로 계산이 되어 이 몫이 수열이 반복되는 횟수가 된다.


그럼 여기에 다시 연속해서 더 할 수 있는 횟수 K를 곱해주게 되면 가장 큰 수가 등장하는 횟수가 된다.


근데 M이 (K + 1)로 항상 나누어 떨어지지 않을 수도 있으니 나눈 나머지 만큼 가장 큰 수가 추가로 더해지므로 이것도 고려를 해줘야한다.


즉 가장 큰 수가 더해지는 횟수를 구한 다음, 이를 이용해 두 번째로 큰 수가 더해지는 횟수까지 구할 수 있기에 이를 응용해 코드를 작성한다.

```Python
n, m, k = map(int(input().split()))
data = list(map(int(input().split())))

data.sort()
first = data[n - 1]
second = data[n - 2]

count = int(m / (k+1)) * k 
count += m % (k + 1) 

result = 0
result += (count) * first
result += (m - count) * second 

print(result)
```

---

### 숫자 카드 게임

---


문제

[![그리디 image](https://slid-users-assets-v1-seoul.s3.ap-northeast-2.amazonaws.com/public/capture_images/19bec09dd9a746e6bf026bdba88700ca/e42e2b98-a5eb-49dc-ab38-91457599effb.png)](undefined)

[![그리디 image](https://slid-users-assets-v1-seoul.s3.ap-northeast-2.amazonaws.com/public/capture_images/19bec09dd9a746e6bf026bdba88700ca/50da4790-094d-487c-b599-d686e4df02b2.png)](undefined)

- **문제해설**


그리디 알고리즘 유형의 문제는 문제 해결을 위한 아이디어를 떠올려야 한다고 계속 강조한다.


이 문제를 푸는 아이디어는 '각 행 마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수'를 찾는 것이다.


문제가 헷갈리기도 하고, 문제 설명이 길어서 지문 이해에 시간이 많이 지체 될 수 있지만, 문제의 아이디어를 떠올리는 것은 쉽다.


입력 조건에서 입력으로 들어오는 수는 모두 10000 이하이므로 단순히 배열에서 가장 작은 수를 찾는 기본 문법을 이용, 각 행에서 가장 작은 수를 찾고 난 뒤에 그 수 중에서 가장 큰 수를 찾는 방식으로 문제 해결이 가능하다.


앞에서 다룬 '큰 수의 법칙'보단 난이도가 낮은 문제라고 한다.


다만, 이 문제를 해결하기 위해서는 리스트에서 가장 가까운 원소를 찾아주는 min() 함수를 이용하거나, 2중 반복문 구조를 사용 가능해야한다.


각 방법에 따른 코드를 보자.

```Python
#min() 함수 이용 방식
n, m = map(int, input().split())

result = 0

for i in range(n):
  data = list(map(int, input().split()))
  #현재줄에서 가장 작은 수 찾기 
  min_value = min(data)
  #'가장 작은 수'들 중에서 가장 큰 수 찾기 
  result = max(result, min_value)
  
print(result)
```

```Python
-#2중 반복문 구조 답안 예시
n, m = map(int, input().split())
result = 0

for i in range(n):
  data = list(map(int, input().split()))
  #현재 줄에서 '가장 작은 수' 찾기
  min_value = 10001
  for a in data:
    min_value = min(min_vlaue, a)
    
  result = max(result, min_value)
  
print(result)
```

---

### 1이 될 때까지

---


**문제**

[![그리디 image](https://slid-users-assets-v1-seoul.s3.ap-northeast-2.amazonaws.com/public/capture_images/19bec09dd9a746e6bf026bdba88700ca/81122ba0-2ade-4f58-8c42-d4603e66fb3c.png)](undefined)


**문제 해설**


이 문제 또한 문제 해결을 위한 아이디어가 가장 중요하다.


주어진 N에 대하여 '최대한 많이 나누기'를 수행하면 된단 것을 알 수 있다.


why ?


어떠한 수가 있을 때 '2이상의 수로 나누는 것'이 '1로 마이너스 연산'보단 숫자를 훨씬 많이 줄일 수 있기 때문이다.


문제에서는 K가 2 이상의 자연수이므로, 가능하면 빼는 것보다 2이상의 수로 나누는 것이 '1을 빼는 것'보다 숫자를 훨씬 많이 줄일 수 있기 때문이다.


예를 들어 N이 9일 때 K가 3이라면 2번만 나누어도 순식간에 N = 9에서 N = 1이 된다.


그러므로 매우 빠르게 1이 될 수 있다.


반면에 -1을 하면 8번을 수행해야만 N = 1을 만들어낼 수 있다.


따라서 다음의 과정을 반복할 수 없을 때 까지 반복하면 정답을 구할 수 있다.

1. N이 K의 배수가 될 때까지 1씩 빼기

2. N을 K로 나누기


예를 들어 N = 25, K = 3이라면 6번의 과정으로 N = 1을 만들 수 있다.


위의 방법이 빠르게 동작하면서 그와 동시에 최적의 해를 보장한단 것을 어떻게 알까


N이 클 수록 K로 나누었을 때 줄어드는 양이 더 많아지기 때문이다.


N이 처음엔 큰 수라고 해도, 나누기를 수행하면서 크기가 빠르게 줄어든다.


다시 말해 K가 2이상이기만하면 k로 나누는 것이 1을 빼는 것보단 항상 빠르게 N의 값을 줄일 수 있으며, N이 결국 1에 도달한다는 것을 알 수 있다.


그러므로 K로 최대한 많이 나눌 수 있도록 하는 것이 최적의 해를 보장하는 것이다.


단순한 예시

```Python
n, k = map(int, input().split())
result = 0

while n >= K:
  while n % k != 0:
    n -= 1
    result += 1
  n //= k
  result += 1

while n > 1:
  n -= 1
  result += 1
  
print(result)
```


하지만 N의 범위가 10만 이하라는 점을 고려하면, 이처럼 일일이 1씩 빼서는 빠르게 처리를 못한다. 다음을 보자.

```Python
n, k = map(int, input().split())
result= 0

while True:
  target = (n // k) * k
  result += (n - taget)
  n = target
  
  if n
