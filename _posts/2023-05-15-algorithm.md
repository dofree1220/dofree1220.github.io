---
title: 주요 알고리즘 이론
categories:
- Algorithm
- 이것이 코딩 테스트다
tag: Algorithm
date: '2023-05-15 09:45:21'
---

여기에 나오는 모든 개념과 알고리즘은 나동빈님의 이것이 코딩 테스트다라는 책과 백준 문제들을 바탕으로 작성됨을 밝힙니다.

# 주요 알고리즘 이론과 실전 문제

[→ 슬리드로 보기](https://app.slid.cc/docs/d2656f9b1f6140028979bacb93a6ae78)


---

---


우리는 우선 `복잡도 (complexity)`에 대해 알 필요가 있다.


복잡도는 알고리즘의 성능을 나타내는 척도를 뜻하는데, `시간 복잡도(time complexity)`와 `공간 복잡도(space Complexity)`로 나눌 수 있다.

- **시간 복잡도**


특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래걸리는지를 의미함

- **공간 복잡도**


특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미함


우리가 위의 두 가지 복잡도를 측정할 때 다음의 두 가지로 분류 및 계산이 가능하다.


**시간 복잡도** : 알고리즘을 위해 필요한 연산의 횟수


**공간 복잡도** : 알고리즘을 위해 필요한 메모리 양


‏‏‎ ‎


효율적으로 알고리즘을 사용한다고 했을 때 보통 시간 복잡도와 공간 복잡도는 일종의 `거래 관계 (trade - off)`가 성립한다.


메모리를 조금 더 많이 사용하는 대신에 반복되는 연산이 생략되거나, 더 많은 정보를 다루며 계산의 복잡도를 줄일 수 있고, 메모리를 더 소모하는 대신에 반복되는 연산을 생략하거나 더 많은 정보를 관리하며 계산의 복잡도를 줄일 수 있다.


실제로 메모리를 더 많이 사용하여 시간을 비약적으로 줄이는 방법으로 `메모이제이션(Memoization)기법`이 존재한다.


‏‏‎ ‎

---

- **시간 복잡도**

---


알고리즘 문제를 풀 때 단순히 '복잡도'라고 하면 보통은 시간 복잡도를 의미한다.


코딩 테스트, 알고리즘 문제에서 가장 어렵게 느끼는 부분이 '시간제한'이기 때문이다.


문제를 푸는 시간이 아닌, 코딩 테스트에서는 작성한 프로그램이 모든 입력을 받아 이를 처리하고 실행하는 결과를 출력하는데까지 걸리는 시간을 의미하는 것이기 때문이다.


해당 시간 안에 동작하는 프로그램을 만들어야 정답 판정을 받기 때문에 시간 복잡도가 중요하다.


‏‏‎ ‎


시간 복잡도를 표현할 때는 빅오(big - o) 표기법을 사용한다.


간단하게 빅오 표기법에 대해 설명하면 가장 빠르게 준비하는 항만을 고려하는 표기법이다.


다시 말해 함수의 상한만을 나타내는 것이다.


예를 들어 N개의 데이터가 있을 때, 모든 데이터의 값을 더한 결과를 출력하는 프로그램을 생각해보자.


이때 우리는 합계를 저장할 하나의 변수를 선언한 뒤에 모든 데이터를 하나씩 확인하며 그 값을 합계 변수에 더해주는 식으로 알고리즘이 작성이 가능하다.


아래 예시 코드를 보자.

```Python
array = [3, 5, 1, 2, 4]  #5개 데이터 (N = 5)
summary = 0  #합계를 저장할 변수

for x in array:
  summary += x
  
print(summary)
```


위 코드는 5개의 데이터를 받아 차례대로 5회 더해준다. (N = 5) 이 때 연산횟수는 N에 비례하는 것을 알 수 있다.


물론 코드에서 summary 변수에 0의 값을 대입하는 연산도 있고, summary 변수의 값을 출력하는 부분도 있다.


하지만 이런 연산의 횟수는 상대적으로 N이 커짐에 따라서 무시할 수 있을 정도로 작아진다.


따라서 위 코드에서 가장 영향력이 큰 연산은 N에 비례하는 연산을 수행하는 반복문 부분임으로 시간 복잡도를 O (N)이라고 표기하는 것이다.


‏‏‎ ‎


또 다른 예시를 보자.

```Python
a = 5
b = 7
print(a + b)

```


a와 b에 값을 대입하는 대입 연산과 출력 함수를 무시하고 보면, 이 소스코드의 연산횟수는 1이다.


단순히 더하기 연산 한 번 수행되기 때문에 이는 상수 연산(시간 복잡도는 O(1)로


표현할 수 있다.


‏‏‎ ‎


또 감을 잡기 위해 다음은 어떤 시간 복잡도를 가질지 보자.

```Python
array = [3, 5, 1, 2, 4]  #5개의 데이터(n = 5)

for i in array:
  for j in array:
    temp = i * j
    print(temp)
```


이 소스코드는 데이터의 개수 (array list 변수의 길이)가 N개 일 때 O(N^2)의 시간 복잡도를 가진다.


2중 반복문을 이용하여 각 원소에 대하여 다른 모든 원소에 대한 곱셈 결과를 매번 출력하기 때문이다.


간단한 2중 반복문이라서 N \* N 만큼의 연산이 필요하단 것을 유추할 수 있다.


하지만 모든 2중 반복문의 시간 복잡도가 O(N^2)가 아니라는 것을 알아야 한다.


소스코드가 내부적으로 다른 함수를 호출한다면 내부함수의 시간복잡도까지 고려해야한다.


따라서 소스코드를 정확히 분석한 뒤에 시간 복잡도를 계산하도록하자.


정렬에 대한 평균 시간 복잡도는 항상 달라지게 된다.


항상 알고리즘 대회나 코딩 테스트는 최악의 경우를 대비한 연산 횟수가 가장 중요하기 때문에 최악의 경우의 시간 복잡도를 우선적으로 고려하도록 하자.


다음은 자주 등장하는 시간 복잡도 표인데, 위쪽에 있을 수록 더 빠르다.


시간 복잡도에 대해 부르는 명칭이 있는데 이것도 알아두도록하자.

| 제목 1 | 제목 2 |
| ---- | ---- |
| 빅오 표기법 | 명칭 |
| O(1) | 상수시간 (Constant time) |
| O(log N) | 로그 시간 (log time) |
| O(N) | 선형 시간 |
| O(N log N) | 로그 선형 시간 |
| O(N^2) | 이차 시간 |
| O(N^3) | 삼차 시간 |
| O(2^n) | 지수 시간 |


빅오 표기법이 항상 절대적인 것은 아니라는 것을 알아두자.


\+ 시간 복잡도에서 '연산'은 프로그래밍 언어에서 지원하는 사칙연산, 비교 연산 등과 같은 기본 연산을 의미한다.


예를 들어 두 정수 a와 b를 더하는 더하기 연산 뿐만 아니라, 두 정수 a와 b의 값을 비교하는 비교 연산 또한 한 번의 연산으로 취급한다.


‏‏‎ ‎


복잡도에 대한 개념에 대해 왜 이렇게 거창하게 TiL을 적느냐는 의문을 가질 수 있을 정도로, 시간 복잡도 분석은 문제풀이의 핵심이다.


알고리즘 문제의 고인물 들은 문제를 해석하기 전에 조건을 먼저 보기도 한다.


문제의 조건부터 확인하면 문제를 풀기 위해 얼마나 효율적인 알고리즘을 작성해야하는지 눈치 챌 수 있기 때문이다.


예를 들어 데이터의 개수 N이 1000만개를 넘어가는데 시간 제한이 1초라면, 최아그이 경우 O(N)의 시간 복잡도로 동작하는 알고리즘을 작성해야할 것이라고 예상할 수 있다.


혹은 데이터의 크기나 탐색 범위가 100억이나 1000억을 넘어가는 경우 '이진 탐색'과 같은 O(log N)의 시간 복잡도를 갖는 알고리즘을 작성해야 할 것이다.


일반적으로 문제를 풀 때의 몇 가지 예시를 보자.(모두 시간 제한이 1초인 문제에 대한 예시이다.)

1. N의 범위가 500일 때 : 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있다.

2. N의 범위가 2000인 경우 : 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 가능하다.

3. N의 범위가 100000일 경우 : 시간 복잡도가 O(N log N)인 알고리즘을 설계하면 가능하다.

4. N의 범위가 10000000인 경우 : 시간 복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있다.

---

- **공간 복잡도**

---


공간 복잡도를 표기할 때도 시간 복잡도를 표기한 것 처럼 빅오 표기법이라는 것을 사용한다.


즉, 공간 복잡도 또한 O (N log N), O(N^2)등으로 표기한다.


다만 앞서 시간 복잡도에서 1초라는 절대적인 제한이 있던 것처럼, 메모리 사용량에도 절대적인 제한이 있다.


일반적으로 메모리 사용량 기준은 MB 단위로 제시된다.


쉽게 말해 알고리즘 문제에서 '시간 제한 1초', 메모리 제한 128MB 와 같은 문장들은 시간 복잡도, 공간 복잡도를 명시하는 것이라는 걸 알 수 있다.


대부분 배열(list)를 사용해서 데이터를 처리하는데 대부분의 문제는 다수의 데이터에 대한 효율적인 처리를 요구한다.


그렇다면 고전적인 프로그래밍 언어에서 정수형 자료형인 int를 기준으로 리스트 크기에 따른 메모리 사용량을 확인해보자.


단, 실제로 컴퓨터 시스템에서 차지하는 메모리양은 컴파일러의 종류에 따라 조금씩 다르게 적용될 수 있다.


‏‏‎ ‎

- int a\[1000\] : 4KB

- int a\[1000000\] : 4MB

- int a\[2000\]\[2000\] : 16MB


‏‏‎ ‎


보통의 문제들은 메모리 사용량을 128 ~ 512 MB 정도로 제한한다.


다시 말해 일반적인 경우 데이터의 개수가 1000만 단위가 넘어가지 않도록 알고리즘 설계를 해야 한단 의미이다. 파이썬에서는 int 자료형이 없지만, 파이썬에서도 대략 100만개 이상의 데이터가 들어갈 수 있는 크기의 리스트를 선언하는 경우는 적다는 것을 기억하자.


만약 리스트의 크기가 1000만 단위 이상이라면 자신의 알고리즘의 설계를 의심해보자.

---

### 시간과 메모리 측정

---


파이썬에서는 프로그램 수행 시간과 메모리 사용량을 측정할 수 있다.


알고리즘을 공부하는 과정에서 시간을 측정하는 작업을 굉장히 많이 사용한다.


실질적으로 알고리즘의 소요 시간을 확인해야 자신이 제대로 알고리즘을 작성하고 있는지 체크할 수 있기 때문이다.


다시 말해 실제 프로그램의 수행 시간을 측정하는 것이 알고리즘의 효율성을 측정하는 가장 기본적인 방법이다.


특정한 프로그램의 수행시간을 측정하는 소스코드 예시는 다음과 같다.

```Python
import time
start_time = time.time()  # 측정 시작

end_time = time.time()  # 측정 종료
print("time : ", end_time - start_time) 수행 시간 출력
```


수행 시간 측정 소스코드의 형태는 일반적으로 위와 같다.


보통 어떤 알고리즘을 설계한 뒤에 시간 복잡도를 경험적으로 증명하고 싶을 때 위와 같은 형태의 코드를 자주 이용한다.


예를 들어 '선택 정렬'과 파이썬의 기본 정렬 라이브러리의 속도를 비교할 때는 다음 쪽과 같이 소스 코드를 작성할 수 있다.


선택 정렬을 사용한다면 최악의 경우 시간 복잡도가 O(N^2)이며, 파이썬의 기본 정렬 라이브러리는 최악의 경우 시간 복잡도 (N log N)을 보장하여 상대적으로 빠르다.


소스코드는 다양한 알고리즘을 접하고 난 두 후에 추가하자.


‏‏‎ ‎


여기서 아랑야 할 점은 자신이 설계한 아록리즘의 성능을 실제로 확인하기 위해서, 시간 측정 라이브러리를 사용해보는 습관을 기르는 것이 좋다.

---


‏‏‎ ‎
